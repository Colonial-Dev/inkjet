#![allow(dead_code)]
#![allow(clippy::items_after_test_module)]
// This module is automatically generated by Inkjet.

use tree_sitter_highlight::HighlightConfiguration;

pub mod ada {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ada() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ada() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ada'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ada/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ada/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ada() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod asm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_asm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_asm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'asm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/asm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_asm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod bash {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_bash() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_bash() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'bash'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/bash/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/bash/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/bash/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_bash() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod bibtex {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_bibtex() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_bibtex() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'bibtex'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/bibtex/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_bibtex() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod blueprint {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_blueprint() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_blueprint() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'blueprint'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/blueprint/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_blueprint() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod c {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_c() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_c() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'c'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/c/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/c/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/c/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_c() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod capnp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_capnp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_capnp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'capnp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/capnp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/capnp/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/capnp/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_capnp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod clojure {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_clojure() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_clojure() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'clojure'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/clojure/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/clojure/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/clojure/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_clojure() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod c_sharp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_c_sharp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_c_sharp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'c_sharp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/c_sharp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/c_sharp/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/c_sharp/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_c_sharp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod commonlisp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_commonlisp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_commonlisp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'commonlisp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/commonlisp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/commonlisp/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_commonlisp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod cpp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_cpp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_cpp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'cpp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/cpp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/cpp/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/cpp/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_cpp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod css {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_css() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_css() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'css'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/css/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/css/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_css() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod cue {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_cue() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_cue() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'cue'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/cue/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/cue/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/cue/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_cue() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod d {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_d() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_d() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'd'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/d/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/d/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_d() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod dart {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_dart() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_dart() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'dart'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/dart/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/dart/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/dart/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_dart() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod diff {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_diff() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_diff() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'diff'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/diff/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_diff() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod dockerfile {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_dockerfile() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_dockerfile() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'dockerfile'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/dockerfile/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/dockerfile/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_dockerfile() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elisp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elisp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elisp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elisp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elisp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elisp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elixir {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elixir() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elixir() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elixir'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elixir/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/elixir/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/elixir/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elixir() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/elm/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod erlang {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_erlang() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_erlang() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'erlang'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/erlang/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_erlang() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod fortran {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_fortran() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_fortran() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'fortran'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/fortran/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_fortran() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod go {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_go() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_go() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'go'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/go/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/go/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/go/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_go() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod gdscript {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_gdscript() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_gdscript() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'gdscript'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/gdscript/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/gdscript/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/gdscript/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_gdscript() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod glsl {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_glsl() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_glsl() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'glsl'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/glsl/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/glsl/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/glsl/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_glsl() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod haskell {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_haskell() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_haskell() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'haskell'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/haskell/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/haskell/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_haskell() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod html {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_html() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_html() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'html'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/html/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/html/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/html/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_html() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod java {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_java() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_java() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'java'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/java/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/java/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/java/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_java() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod javascript {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_javascript() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_javascript() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'javascript'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/javascript/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/javascript/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/javascript/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_javascript() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod json {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_json() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_json() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'json'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/json/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/json/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_json() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod julia {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_julia() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_julia() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'julia'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/julia/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/julia/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/julia/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_julia() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod kotlin {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_kotlin() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_kotlin() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'kotlin'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/kotlin/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/kotlin/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/kotlin/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_kotlin() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod latex {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_latex() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_latex() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'latex'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/latex/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/latex/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_latex() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod llvm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_llvm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_llvm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'llvm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/llvm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_llvm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod lua {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_lua() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_lua() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'lua'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_lua() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod make {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_make() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_make() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'make'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/make/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/make/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_make() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod matlab {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_matlab() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_matlab() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'matlab'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/matlab/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/matlab/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/matlab/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_matlab() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod meson {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_meson() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_meson() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'meson'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/meson/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/meson/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_meson() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod nim {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_nim() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_nim() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'nim'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_nim() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod nix {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_nix() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_nix() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'nix'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/nix/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/nix/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/nix/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_nix() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ocaml {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ocaml() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ocaml() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ocaml'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ocaml/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/ocaml/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/ocaml/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ocaml() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ocaml_interface {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ocaml_interface() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ocaml_interface() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ocaml_interface'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ocaml_interface/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/ocaml_interface/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/ocaml_interface/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ocaml_interface() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod openscad {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_openscad() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_openscad() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'openscad'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/openscad/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/openscad/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/openscad/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_openscad() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod pascal {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_pascal() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_pascal() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'pascal'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/pascal/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/pascal/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/pascal/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_pascal() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod perl {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_perl() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_perl() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'perl'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/perl/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/perl/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_perl() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod php {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_php() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_php() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'php'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/php/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/php/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/php/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_php() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod proto {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_proto() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_proto() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'proto'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/proto/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_proto() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod python {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_python() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_python() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'python'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/python/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/python/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/python/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_python() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod r {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_r() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_r() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'r'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/r/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/r/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/r/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_r() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod racket {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_racket() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_racket() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'racket'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/racket/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/racket/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_racket() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod regex {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_regex() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_regex() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'regex'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/regex/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_regex() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ruby {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ruby() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ruby() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ruby'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ruby/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/ruby/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/ruby/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ruby() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod rust {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_rust() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_rust() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'rust'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/rust/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/rust/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/rust/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_rust() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scala {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scala() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scala() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scala'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/scala/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/scala/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/scala/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scala() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scheme {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scheme() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scheme() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scheme'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/scheme/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/scheme/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scheme() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scss {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scss() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scss() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scss'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/scss/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scss() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod sql {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_sql() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_sql() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'sql'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/sql/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/sql/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_sql() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod toml {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_toml() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_toml() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'toml'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/toml/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/toml/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/toml/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_toml() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod typescript {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_typescript() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_typescript() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'typescript'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/typescript/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/typescript/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/typescript/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_typescript() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod x86asm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_x86asm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_x86asm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'x86asm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/x86asm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_x86asm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod yaml {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_yaml() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_yaml() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'yaml'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/yaml/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/yaml/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/yaml/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_yaml() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod wgsl {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_wgsl() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_wgsl() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'wgsl'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/wgsl/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_wgsl() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod zig {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_zig() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_zig() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'zig'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/zig/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/zig/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/zig/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_zig() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

/// The set of all languages supported by Inkjet.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Language {
    Ada,
    GenericAsm,
    Bash,
    Bibtex,
    Blueprint,
    C,
    Capnp,
    Clojure,
    CSharp,
    CommonLisp,
    Cpp,
    Css,
    Cue,
    D,
    Dart,
    Diff,
    Dockerfile,
    Elisp,
    Elixir,
    Elm,
    Erlang,
    Fortran,
    Go,
    GDScript,
    Glsl,
    Haskell,
    Html,
    Java,
    Javascript,
    Json,
    Julia,
    Kotlin,
    Latex,
    Llvm,
    Lua,
    Make,
    Matlab,
    Meson,
    Nim,
    Nix,
    Ocaml,
    OcamlInterface,
    OpenScad,
    Pascal,
    Perl,
    Php,
    ProtoBuf,
    Python,
    R,
    Racket,
    Regex,
    Ruby,
    Rust,
    Scala,
    Scheme,
    Scss,
    Sql,
    Toml,
    Typescript,
    X86asm,
    Yaml,
    Wgsl,
    Zig,
}

impl Language {
    pub(crate) const ALL_LANGS: &[Self] = &[
        Self::Ada,
        Self::GenericAsm,
        Self::Bash,
        Self::Bibtex,
        Self::Blueprint,
        Self::C,
        Self::Capnp,
        Self::Clojure,
        Self::CSharp,
        Self::CommonLisp,
        Self::Cpp,
        Self::Css,
        Self::Cue,
        Self::D,
        Self::Dart,
        Self::Diff,
        Self::Dockerfile,
        Self::Elisp,
        Self::Elixir,
        Self::Elm,
        Self::Erlang,
        Self::Fortran,
        Self::Go,
        Self::GDScript,
        Self::Glsl,
        Self::Haskell,
        Self::Html,
        Self::Java,
        Self::Javascript,
        Self::Json,
        Self::Julia,
        Self::Kotlin,
        Self::Latex,
        Self::Llvm,
        Self::Lua,
        Self::Make,
        Self::Matlab,
        Self::Meson,
        Self::Nim,
        Self::Nix,
        Self::Ocaml,
        Self::OcamlInterface,
        Self::OpenScad,
        Self::Pascal,
        Self::Perl,
        Self::Php,
        Self::ProtoBuf,
        Self::Python,
        Self::R,
        Self::Racket,
        Self::Regex,
        Self::Ruby,
        Self::Rust,
        Self::Scala,
        Self::Scheme,
        Self::Scss,
        Self::Sql,
        Self::Toml,
        Self::Typescript,
        Self::X86asm,
        Self::Yaml,
        Self::Wgsl,
        Self::Zig,
    ];

    /// Attempts to convert a string token (such as `rust` or `rs`) into the corresponding language.
    /// 
    /// Returns [`None`] if the language was not found.
    /// 
    /// The tokens for each language are sourced from its `name` and `aliases` keys in
    /// `config/languages.toml`.
    pub fn from_token(token: &str) -> Option<Self> {
        match token {
            "ada" => Some(Self::Ada),
            "asm" => Some(Self::GenericAsm),
            "bash" => Some(Self::Bash),
            "bibtex" => Some(Self::Bibtex),
            "bib" => Some(Self::Bibtex),
            "blueprint" => Some(Self::Blueprint),
            "blp" => Some(Self::Blueprint),
            "c" => Some(Self::C),
            "h" => Some(Self::C),
            "capnp" => Some(Self::Capnp),
            "clojure" => Some(Self::Clojure),
            "clj" => Some(Self::Clojure),
            "cljc" => Some(Self::Clojure),
            "c_sharp" => Some(Self::CSharp),
            "c#" => Some(Self::CSharp),
            "csharp" => Some(Self::CSharp),
            "cs" => Some(Self::CSharp),
            "commonlisp" => Some(Self::CommonLisp),
            "cl" => Some(Self::CommonLisp),
            "lisp" => Some(Self::CommonLisp),
            "common-lisp" => Some(Self::CommonLisp),
            "cpp" => Some(Self::Cpp),
            "c++" => Some(Self::Cpp),
            "hpp" => Some(Self::Cpp),
            "h++" => Some(Self::Cpp),
            "cc" => Some(Self::Cpp),
            "hh" => Some(Self::Cpp),
            "css" => Some(Self::Css),
            "cue" => Some(Self::Cue),
            "d" => Some(Self::D),
            "dlang" => Some(Self::D),
            "dart" => Some(Self::Dart),
            "diff" => Some(Self::Diff),
            "dockerfile" => Some(Self::Dockerfile),
            "docker" => Some(Self::Dockerfile),
            "elisp" => Some(Self::Elisp),
            "el" => Some(Self::Elisp),
            "emacs-lisp" => Some(Self::Elisp),
            "elixir" => Some(Self::Elixir),
            "ex" => Some(Self::Elixir),
            "eex" => Some(Self::Elixir),
            "exs" => Some(Self::Elixir),
            "leex" => Some(Self::Elixir),
            "elm" => Some(Self::Elm),
            "erlang" => Some(Self::Erlang),
            "erl" => Some(Self::Erlang),
            "hrl" => Some(Self::Erlang),
            "es" => Some(Self::Erlang),
            "escript" => Some(Self::Erlang),
            "fortran" => Some(Self::Fortran),
            "go" => Some(Self::Go),
            "golang" => Some(Self::Go),
            "gdscript" => Some(Self::GDScript),
            "gd" => Some(Self::GDScript),
            "glsl" => Some(Self::Glsl),
            "haskell" => Some(Self::Haskell),
            "hs" => Some(Self::Haskell),
            "html" => Some(Self::Html),
            "htm" => Some(Self::Html),
            "java" => Some(Self::Java),
            "javascript" => Some(Self::Javascript),
            "js" => Some(Self::Javascript),
            "json" => Some(Self::Json),
            "julia" => Some(Self::Julia),
            "jl" => Some(Self::Julia),
            "kotlin" => Some(Self::Kotlin),
            "kt" => Some(Self::Kotlin),
            "kts" => Some(Self::Kotlin),
            "latex" => Some(Self::Latex),
            "tex" => Some(Self::Latex),
            "llvm" => Some(Self::Llvm),
            "lua" => Some(Self::Lua),
            "make" => Some(Self::Make),
            "mk" => Some(Self::Make),
            "makefile" => Some(Self::Make),
            "matlab" => Some(Self::Matlab),
            "m" => Some(Self::Matlab),
            "meson" => Some(Self::Meson),
            "nim" => Some(Self::Nim),
            "nix" => Some(Self::Nix),
            "ocaml" => Some(Self::Ocaml),
            "ml" => Some(Self::Ocaml),
            "ocaml_interface" => Some(Self::OcamlInterface),
            "mli" => Some(Self::OcamlInterface),
            "openscad" => Some(Self::OpenScad),
            "scad" => Some(Self::OpenScad),
            "pascal" => Some(Self::Pascal),
            "perl" => Some(Self::Perl),
            "pl" => Some(Self::Perl),
            "php" => Some(Self::Php),
            "proto" => Some(Self::ProtoBuf),
            "protobuf" => Some(Self::ProtoBuf),
            "python" => Some(Self::Python),
            "py" => Some(Self::Python),
            "r" => Some(Self::R),
            "racket" => Some(Self::Racket),
            "rkt" => Some(Self::Racket),
            "regex" => Some(Self::Regex),
            "ruby" => Some(Self::Ruby),
            "rb" => Some(Self::Ruby),
            "rust" => Some(Self::Rust),
            "rs" => Some(Self::Rust),
            "scala" => Some(Self::Scala),
            "scheme" => Some(Self::Scheme),
            "scm" => Some(Self::Scheme),
            "ss" => Some(Self::Scheme),
            "scss" => Some(Self::Scss),
            "sql" => Some(Self::Sql),
            "toml" => Some(Self::Toml),
            "typescript" => Some(Self::Typescript),
            "ts" => Some(Self::Typescript),
            "x86asm" => Some(Self::X86asm),
            "x86" => Some(Self::X86asm),
            "yaml" => Some(Self::Yaml),
            "wgsl" => Some(Self::Wgsl),
            "zig" => Some(Self::Zig),
            _ => None,
        }
    }

    pub(crate) fn config(&self) -> &'static HighlightConfiguration {
        match *self {
            Self::Ada => &ada::CONFIG,
            Self::GenericAsm => &asm::CONFIG,
            Self::Bash => &bash::CONFIG,
            Self::Bibtex => &bibtex::CONFIG,
            Self::Blueprint => &blueprint::CONFIG,
            Self::C => &c::CONFIG,
            Self::Capnp => &capnp::CONFIG,
            Self::Clojure => &clojure::CONFIG,
            Self::CSharp => &c_sharp::CONFIG,
            Self::CommonLisp => &commonlisp::CONFIG,
            Self::Cpp => &cpp::CONFIG,
            Self::Css => &css::CONFIG,
            Self::Cue => &cue::CONFIG,
            Self::D => &d::CONFIG,
            Self::Dart => &dart::CONFIG,
            Self::Diff => &diff::CONFIG,
            Self::Dockerfile => &dockerfile::CONFIG,
            Self::Elisp => &elisp::CONFIG,
            Self::Elixir => &elixir::CONFIG,
            Self::Elm => &elm::CONFIG,
            Self::Erlang => &erlang::CONFIG,
            Self::Fortran => &fortran::CONFIG,
            Self::Go => &go::CONFIG,
            Self::GDScript => &gdscript::CONFIG,
            Self::Glsl => &glsl::CONFIG,
            Self::Haskell => &haskell::CONFIG,
            Self::Html => &html::CONFIG,
            Self::Java => &java::CONFIG,
            Self::Javascript => &javascript::CONFIG,
            Self::Json => &json::CONFIG,
            Self::Julia => &julia::CONFIG,
            Self::Kotlin => &kotlin::CONFIG,
            Self::Latex => &latex::CONFIG,
            Self::Llvm => &llvm::CONFIG,
            Self::Lua => &lua::CONFIG,
            Self::Make => &make::CONFIG,
            Self::Matlab => &matlab::CONFIG,
            Self::Meson => &meson::CONFIG,
            Self::Nim => &nim::CONFIG,
            Self::Nix => &nix::CONFIG,
            Self::Ocaml => &ocaml::CONFIG,
            Self::OcamlInterface => &ocaml_interface::CONFIG,
            Self::OpenScad => &openscad::CONFIG,
            Self::Pascal => &pascal::CONFIG,
            Self::Perl => &perl::CONFIG,
            Self::Php => &php::CONFIG,
            Self::ProtoBuf => &proto::CONFIG,
            Self::Python => &python::CONFIG,
            Self::R => &r::CONFIG,
            Self::Racket => &racket::CONFIG,
            Self::Regex => &regex::CONFIG,
            Self::Ruby => &ruby::CONFIG,
            Self::Rust => &rust::CONFIG,
            Self::Scala => &scala::CONFIG,
            Self::Scheme => &scheme::CONFIG,
            Self::Scss => &scss::CONFIG,
            Self::Sql => &sql::CONFIG,
            Self::Toml => &toml::CONFIG,
            Self::Typescript => &typescript::CONFIG,
            Self::X86asm => &x86asm::CONFIG,
            Self::Yaml => &yaml::CONFIG,
            Self::Wgsl => &wgsl::CONFIG,
            Self::Zig => &zig::CONFIG,
        }
    }
}
