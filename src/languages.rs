#![allow(dead_code)]
#![allow(clippy::items_after_test_module)]
// This module is automatically generated by Inkjet.

use tree_sitter_highlight::HighlightConfiguration;

pub mod ada {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ada() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ada() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ada'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ada/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ada/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ada() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod asm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_asm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_asm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'asm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/asm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_asm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod bash {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_bash() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_bash() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'bash'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/bash/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_bash() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod bibtex {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_bibtex() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_bibtex() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'bibtex'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/bibtex/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/bibtex/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_bibtex() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod blueprint {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_blueprint() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_blueprint() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'blueprint'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/blueprint/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_blueprint() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod c {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_c() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_c() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'c'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/c/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_c() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod capnp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_capnp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_capnp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'capnp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/capnp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/capnp/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/capnp/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_capnp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod clojure {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_clojure() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_clojure() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'clojure'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/clojure/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_clojure() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod c_sharp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_c_sharp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_c_sharp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'c_sharp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/c_sharp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_c_sharp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod commonlisp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_commonlisp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_commonlisp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'commonlisp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_commonlisp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod cpp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_cpp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_cpp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'cpp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/cpp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/cpp/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_cpp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod css {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_css() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_css() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'css'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/css/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_css() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod cue {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_cue() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_cue() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'cue'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/cue/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/cue/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/cue/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_cue() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod d {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_d() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_d() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'd'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/d/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/d/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_d() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod dart {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_dart() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_dart() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'dart'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/dart/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_dart() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod diff {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_diff() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_diff() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'diff'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/diff/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_diff() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod dockerfile {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_dockerfile() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_dockerfile() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'dockerfile'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/dockerfile/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_dockerfile() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elisp {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elisp() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elisp() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elisp'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elisp/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elisp() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elixir {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elixir() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elixir() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elixir'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elixir/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/elixir/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elixir() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod elm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_elm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_elm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'elm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/elm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/elm/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/elm/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_elm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod erlang {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_erlang() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_erlang() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'erlang'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/erlang/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_erlang() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod fortran {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_fortran() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_fortran() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'fortran'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/fortran/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_fortran() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod go {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_go() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_go() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'go'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/go/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_go() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod glsl {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_glsl() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_glsl() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'glsl'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/glsl/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_glsl() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod haskell {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_haskell() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_haskell() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'haskell'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/haskell/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/haskell/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_haskell() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod html {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_html() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_html() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'html'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/html/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/html/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_html() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod java {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_java() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_java() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'java'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/java/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_java() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod javascript {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_javascript() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_javascript() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'javascript'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/javascript/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/javascript/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/javascript/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_javascript() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod json {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_json() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_json() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'json'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/json/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_json() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod kotlin {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_kotlin() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_kotlin() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'kotlin'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/kotlin/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_kotlin() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod llvm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_llvm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_llvm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'llvm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/llvm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_llvm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod lua {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_lua() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_lua() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'lua'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/lua/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/lua/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/lua/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_lua() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod make {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_make() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_make() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'make'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/make/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_make() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod matlab {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_matlab() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_matlab() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'matlab'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_matlab() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod meson {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_meson() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_meson() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'meson'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/meson/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_meson() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod nim {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_nim() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_nim() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'nim'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_nim() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod nix {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_nix() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_nix() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'nix'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/nix/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/nix/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/nix/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_nix() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ocaml {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ocaml() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ocaml() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ocaml'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ocaml/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ocaml/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ocaml() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ocaml_interface {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ocaml_interface() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ocaml_interface() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ocaml_interface'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ocaml_interface/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ocaml_interface/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ocaml_interface() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod openscad {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_openscad() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_openscad() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'openscad'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/openscad/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/openscad/queries/injections.scm");
    pub const LOCALS_QUERY: &str = include_str!("../languages/openscad/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_openscad() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod pascal {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_pascal() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_pascal() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'pascal'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/pascal/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/pascal/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_pascal() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod php {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_php() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_php() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'php'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/php/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/php/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_php() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod proto {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_proto() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_proto() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'proto'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/proto/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_proto() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod python {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_python() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_python() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'python'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/python/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_python() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod r {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_r() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_r() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'r'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/r/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/r/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_r() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod racket {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_racket() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_racket() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'racket'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/racket/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/racket/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_racket() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod regex {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_regex() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_regex() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'regex'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/regex/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_regex() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod ruby {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_ruby() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_ruby() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'ruby'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/ruby/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ruby/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_ruby() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod rust {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_rust() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_rust() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'rust'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/rust/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/rust/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_rust() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scala {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scala() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scala() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scala'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scala() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scheme {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scheme() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scheme() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scheme'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/scheme/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scheme() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod scss {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_scss() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_scss() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'scss'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/scss/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_scss() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod sql {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_sql() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_sql() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'sql'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/sql/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_sql() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod swift {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_swift() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_swift() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'swift'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/swift/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/swift/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_swift() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod toml {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_toml() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_toml() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'toml'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/toml/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_toml() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod typescript {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_typescript() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_typescript() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'typescript'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/typescript/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/typescript/queries/locals.scm");

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_typescript() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod x86asm {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_x86asm() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_x86asm() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'x86asm'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/x86asm/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_x86asm() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod wgsl {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_wgsl() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_wgsl() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'wgsl'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/wgsl/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_wgsl() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

pub mod zig {
    use once_cell::sync::Lazy;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;

    use crate::constants::HIGHLIGHT_NAMES;

    extern "C" {
        pub fn tree_sitter_zig() -> Language;
    }

    pub static CONFIG: Lazy<HighlightConfiguration> = Lazy::new(|| {
        let mut config = HighlightConfiguration::new(
            unsafe { tree_sitter_zig() },
            HIGHLIGHT_QUERY,
            INJECTIONS_QUERY,
            LOCALS_QUERY,
        ).expect("Failed to load highlight configuration for language 'zig'!");

        config.configure(HIGHLIGHT_NAMES);

        config
    });

    pub const HIGHLIGHT_QUERY: &str = include_str!("../languages/zig/queries/highlights.scm");
    pub const INJECTIONS_QUERY: &str = include_str!("../languages/zig/queries/injections.scm");
    pub const LOCALS_QUERY: &str = "";

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { super::tree_sitter_zig() })
                .expect("Grammar should load successfully.");
        }

        #[test]
        fn config_loading() {
            let _cfg = Lazy::get(&CONFIG);
        }
    }
}

/// The set of all languages supported by Inkjet.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Language {
    Ada,
    GenericAsm,
    Bash,
    Bibtex,
    Blueprint,
    C,
    Capnp,
    Clojure,
    CSharp,
    CommonLisp,
    Cpp,
    Css,
    Cue,
    D,
    Dart,
    Diff,
    Dockerfile,
    Elisp,
    Elixir,
    Elm,
    Erlang,
    Fortran,
    Go,
    Glsl,
    Haskell,
    Html,
    Java,
    Javascript,
    Json,
    Kotlin,
    Llvm,
    Lua,
    Make,
    Matlab,
    Meson,
    Nim,
    Nix,
    Ocaml,
    OcamlInterface,
    OpenScad,
    Pascal,
    Php,
    ProtoBuf,
    Python,
    R,
    Racket,
    Regex,
    Ruby,
    Rust,
    Scala,
    Scheme,
    Scss,
    Sql,
    Swift,
    Toml,
    Typescript,
    X86asm,
    Wgsl,
    Zig,
}

impl Language {
    pub(crate) const ALL_LANGS: &[Self] = &[
        Self::Ada,
        Self::GenericAsm,
        Self::Bash,
        Self::Bibtex,
        Self::Blueprint,
        Self::C,
        Self::Capnp,
        Self::Clojure,
        Self::CSharp,
        Self::CommonLisp,
        Self::Cpp,
        Self::Css,
        Self::Cue,
        Self::D,
        Self::Dart,
        Self::Diff,
        Self::Dockerfile,
        Self::Elisp,
        Self::Elixir,
        Self::Elm,
        Self::Erlang,
        Self::Fortran,
        Self::Go,
        Self::Glsl,
        Self::Haskell,
        Self::Html,
        Self::Java,
        Self::Javascript,
        Self::Json,
        Self::Kotlin,
        Self::Llvm,
        Self::Lua,
        Self::Make,
        Self::Matlab,
        Self::Meson,
        Self::Nim,
        Self::Nix,
        Self::Ocaml,
        Self::OcamlInterface,
        Self::OpenScad,
        Self::Pascal,
        Self::Php,
        Self::ProtoBuf,
        Self::Python,
        Self::R,
        Self::Racket,
        Self::Regex,
        Self::Ruby,
        Self::Rust,
        Self::Scala,
        Self::Scheme,
        Self::Scss,
        Self::Sql,
        Self::Swift,
        Self::Toml,
        Self::Typescript,
        Self::X86asm,
        Self::Wgsl,
        Self::Zig,
    ];

    /// Attempts to convert a string token (such as `rust` or `rs`) into the corresponding language.
    /// 
    /// Returns [`None`] if the language was not found.
    /// 
    /// The tokens for each language are sourced from its `name` and `aliases` keys in
    /// `config/languages.toml`.
    pub fn from_token(token: &str) -> Option<Self> {
        LANGUAGE_TOKENS.get(token).map(ToOwned::to_owned)
    }

    pub(crate) fn config(&self) -> &'static HighlightConfiguration {
        match *self {
            Self::Ada => &ada::CONFIG,
            Self::GenericAsm => &asm::CONFIG,
            Self::Bash => &bash::CONFIG,
            Self::Bibtex => &bibtex::CONFIG,
            Self::Blueprint => &blueprint::CONFIG,
            Self::C => &c::CONFIG,
            Self::Capnp => &capnp::CONFIG,
            Self::Clojure => &clojure::CONFIG,
            Self::CSharp => &c_sharp::CONFIG,
            Self::CommonLisp => &commonlisp::CONFIG,
            Self::Cpp => &cpp::CONFIG,
            Self::Css => &css::CONFIG,
            Self::Cue => &cue::CONFIG,
            Self::D => &d::CONFIG,
            Self::Dart => &dart::CONFIG,
            Self::Diff => &diff::CONFIG,
            Self::Dockerfile => &dockerfile::CONFIG,
            Self::Elisp => &elisp::CONFIG,
            Self::Elixir => &elixir::CONFIG,
            Self::Elm => &elm::CONFIG,
            Self::Erlang => &erlang::CONFIG,
            Self::Fortran => &fortran::CONFIG,
            Self::Go => &go::CONFIG,
            Self::Glsl => &glsl::CONFIG,
            Self::Haskell => &haskell::CONFIG,
            Self::Html => &html::CONFIG,
            Self::Java => &java::CONFIG,
            Self::Javascript => &javascript::CONFIG,
            Self::Json => &json::CONFIG,
            Self::Kotlin => &kotlin::CONFIG,
            Self::Llvm => &llvm::CONFIG,
            Self::Lua => &lua::CONFIG,
            Self::Make => &make::CONFIG,
            Self::Matlab => &matlab::CONFIG,
            Self::Meson => &meson::CONFIG,
            Self::Nim => &nim::CONFIG,
            Self::Nix => &nix::CONFIG,
            Self::Ocaml => &ocaml::CONFIG,
            Self::OcamlInterface => &ocaml_interface::CONFIG,
            Self::OpenScad => &openscad::CONFIG,
            Self::Pascal => &pascal::CONFIG,
            Self::Php => &php::CONFIG,
            Self::ProtoBuf => &proto::CONFIG,
            Self::Python => &python::CONFIG,
            Self::R => &r::CONFIG,
            Self::Racket => &racket::CONFIG,
            Self::Regex => &regex::CONFIG,
            Self::Ruby => &ruby::CONFIG,
            Self::Rust => &rust::CONFIG,
            Self::Scala => &scala::CONFIG,
            Self::Scheme => &scheme::CONFIG,
            Self::Scss => &scss::CONFIG,
            Self::Sql => &sql::CONFIG,
            Self::Swift => &swift::CONFIG,
            Self::Toml => &toml::CONFIG,
            Self::Typescript => &typescript::CONFIG,
            Self::X86asm => &x86asm::CONFIG,
            Self::Wgsl => &wgsl::CONFIG,
            Self::Zig => &zig::CONFIG,
        }
    }
}

static LANGUAGE_TOKENS: phf::Map<&'static str, Language> = 
::phf::Map {
    key: 10121458955350035957,
    disps: &[
        (0, 18),
        (1, 4),
        (0, 1),
        (0, 25),
        (1, 52),
        (0, 54),
        (0, 4),
        (0, 39),
        (0, 0),
        (3, 21),
        (0, 34),
        (8, 12),
        (6, 69),
        (0, 13),
        (6, 104),
        (0, 0),
        (0, 5),
        (52, 48),
        (2, 42),
        (2, 0),
        (11, 5),
        (12, 70),
    ],
    entries: &[
        ("scala", Language::Scala),
        ("emacs-lisp", Language::Elisp),
        ("kts", Language::Kotlin),
        ("csharp", Language::CSharp),
        ("rkt", Language::Racket),
        ("typescript", Language::Typescript),
        ("css", Language::Css),
        ("bash", Language::Bash),
        ("cpp", Language::Cpp),
        ("cljc", Language::Clojure),
        ("json", Language::Json),
        ("c", Language::C),
        ("ocaml", Language::Ocaml),
        ("rust", Language::Rust),
        ("hpp", Language::Cpp),
        ("elixir", Language::Elixir),
        ("js", Language::Javascript),
        ("zig", Language::Zig),
        ("javascript", Language::Javascript),
        ("dart", Language::Dart),
        ("el", Language::Elisp),
        ("pascal", Language::Pascal),
        ("cc", Language::Cpp),
        ("toml", Language::Toml),
        ("kotlin", Language::Kotlin),
        ("rb", Language::Ruby),
        ("r", Language::R),
        ("wgsl", Language::Wgsl),
        ("common-lisp", Language::CommonLisp),
        ("clj", Language::Clojure),
        ("regex", Language::Regex),
        ("lua", Language::Lua),
        ("capnp", Language::Capnp),
        ("rs", Language::Rust),
        ("nim", Language::Nim),
        ("scad", Language::OpenScad),
        ("erlang", Language::Erlang),
        ("h", Language::C),
        ("scm", Language::Scheme),
        ("glsl", Language::Glsl),
        ("cl", Language::CommonLisp),
        ("d", Language::D),
        ("proto", Language::ProtoBuf),
        ("swift", Language::Swift),
        ("lisp", Language::CommonLisp),
        ("blueprint", Language::Blueprint),
        ("htm", Language::Html),
        ("sql", Language::Sql),
        ("docker", Language::Dockerfile),
        ("c++", Language::Cpp),
        ("kt", Language::Kotlin),
        ("diff", Language::Diff),
        ("hs", Language::Haskell),
        ("eex", Language::Elixir),
        ("mli", Language::OcamlInterface),
        ("escript", Language::Erlang),
        ("c_sharp", Language::CSharp),
        ("protobuf", Language::ProtoBuf),
        ("openscad", Language::OpenScad),
        ("go", Language::Go),
        ("scss", Language::Scss),
        ("hrl", Language::Erlang),
        ("ada", Language::Ada),
        ("bibtex", Language::Bibtex),
        ("x86", Language::X86asm),
        ("ocaml_interface", Language::OcamlInterface),
        ("h++", Language::Cpp),
        ("mk", Language::Make),
        ("cue", Language::Cue),
        ("ruby", Language::Ruby),
        ("cs", Language::CSharp),
        ("x86asm", Language::X86asm),
        ("scheme", Language::Scheme),
        ("commonlisp", Language::CommonLisp),
        ("llvm", Language::Llvm),
        ("exs", Language::Elixir),
        ("ts", Language::Typescript),
        ("ss", Language::Scheme),
        ("asm", Language::GenericAsm),
        ("php", Language::Php),
        ("java", Language::Java),
        ("html", Language::Html),
        ("hh", Language::Cpp),
        ("elm", Language::Elm),
        ("erl", Language::Erlang),
        ("dlang", Language::D),
        ("ml", Language::Ocaml),
        ("blp", Language::Blueprint),
        ("m", Language::Matlab),
        ("py", Language::Python),
        ("python", Language::Python),
        ("dockerfile", Language::Dockerfile),
        ("bib", Language::Bibtex),
        ("meson", Language::Meson),
        ("leex", Language::Elixir),
        ("matlab", Language::Matlab),
        ("haskell", Language::Haskell),
        ("make", Language::Make),
        ("fortran", Language::Fortran),
        ("elisp", Language::Elisp),
        ("es", Language::Erlang),
        ("c#", Language::CSharp),
        ("clojure", Language::Clojure),
        ("golang", Language::Go),
        ("racket", Language::Racket),
        ("ex", Language::Elixir),
        ("nix", Language::Nix),
        ("makefile", Language::Make),
    ],
};

