//! This module is automatically generated by Inkjet.
#![allow(dead_code)]
#![allow(clippy::items_after_test_module)]
use tree_sitter_highlight::HighlightConfiguration;
#[cfg(feature = "language-ada")]
pub mod ada {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_ada() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_ada() },
                "ada",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'ada'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/ada/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ada/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_ada() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-asm")]
pub mod asm {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_asm() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_asm() },
                "asm",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'asm'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/asm/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/asm/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_asm() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-awk")]
pub mod awk {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_awk() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_awk() },
                "awk",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'awk'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/awk/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/awk/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_awk() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-bash")]
pub mod bash {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_bash() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_bash() },
                "bash",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'bash'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/bash/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_bash() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-bibtex")]
pub mod bibtex {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_bibtex() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_bibtex() },
                "bibtex",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'bibtex'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/bibtex/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/bibtex/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_bibtex() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-bicep")]
pub mod bicep {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_bicep() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_bicep() },
                "bicep",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'bicep'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/bicep/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/bicep/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/bicep/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_bicep() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-blueprint")]
pub mod blueprint {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_blueprint() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_blueprint() },
                "blueprint",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'blueprint'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/blueprint/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_blueprint() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-c")]
pub mod c {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_c() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_c() },
                "c",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'c'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/c/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/c/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_c() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-capnp")]
pub mod capnp {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_capnp() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_capnp() },
                "capnp",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'capnp'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/capnp/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/capnp/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/capnp/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_capnp() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-clojure")]
pub mod clojure {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_clojure() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_clojure() },
                "clojure",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'clojure'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/clojure/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/clojure/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_clojure() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-c-sharp")]
pub mod c_sharp {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_c_sharp() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_c_sharp() },
                "c_sharp",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'c_sharp'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/c_sharp/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_c_sharp() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-cpp")]
pub mod cpp {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_cpp() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_cpp() },
                "cpp",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'cpp'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/cpp/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/cpp/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_cpp() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-css")]
pub mod css {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_css() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_css() },
                "css",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'css'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/css/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/css/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_css() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-cue")]
pub mod cue {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_cue() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_cue() },
                "cue",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'cue'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/cue/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/cue/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/cue/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_cue() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-d")]
pub mod d {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_d() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_d() },
                "d",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'd'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/d/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/d/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_d() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-dart")]
pub mod dart {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_dart() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_dart() },
                "dart",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'dart'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/dart/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_dart() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-diff")]
pub mod diff {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_diff() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_diff() },
                "diff",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'diff'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/diff/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_diff() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-dockerfile")]
pub mod dockerfile {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_dockerfile() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_dockerfile() },
                "dockerfile",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'dockerfile'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/dockerfile/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/dockerfile/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_dockerfile() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-eex")]
pub mod eex {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_eex() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_eex() },
                "eex",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'eex'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/eex/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/eex/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_eex() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-elisp")]
pub mod elisp {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_elisp() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_elisp() },
                "elisp",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'elisp'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/elisp/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_elisp() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-elixir")]
pub mod elixir {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_elixir() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_elixir() },
                "elixir",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'elixir'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/elixir/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/elixir/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_elixir() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-elm")]
pub mod elm {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_elm() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_elm() },
                "elm",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'elm'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/elm/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/elm/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/elm/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_elm() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-erlang")]
pub mod erlang {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_erlang() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_erlang() },
                "erlang",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'erlang'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/erlang/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_erlang() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-forth")]
pub mod forth {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_forth() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_forth() },
                "forth",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'forth'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/forth/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_forth() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-fortran")]
pub mod fortran {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_fortran() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_fortran() },
                "fortran",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'fortran'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/fortran/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_fortran() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-fish")]
pub mod fish {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_fish() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_fish() },
                "fish",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'fish'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/fish/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_fish() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-gdscript")]
pub mod gdscript {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_gdscript() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_gdscript() },
                "gdscript",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'gdscript'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/gdscript/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/gdscript/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_gdscript() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-gleam")]
pub mod gleam {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_gleam() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_gleam() },
                "gleam",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'gleam'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/gleam/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/gleam/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/gleam/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_gleam() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-glsl")]
pub mod glsl {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_glsl() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_glsl() },
                "glsl",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'glsl'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/glsl/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/glsl/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/glsl/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_glsl() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-go")]
pub mod go {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_go() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_go() },
                "go",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'go'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/go/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_go() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-haskell")]
pub mod haskell {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_haskell() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_haskell() },
                "haskell",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'haskell'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/haskell/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/haskell/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/haskell/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_haskell() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-hcl")]
pub mod hcl {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_hcl() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_hcl() },
                "hcl",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'hcl'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/hcl/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/hcl/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_hcl() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-heex")]
pub mod heex {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_heex() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_heex() },
                "heex",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'heex'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/heex/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/heex/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_heex() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-html")]
pub mod html {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_html() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_html() },
                "html",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'html'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/html/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/html/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_html() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-ini")]
pub mod ini {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_ini() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_ini() },
                "ini",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'ini'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/ini/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_ini() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-java")]
pub mod java {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_java() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_java() },
                "java",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'java'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/java/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_java() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-javascript")]
pub mod javascript {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_javascript() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_javascript() },
                "javascript",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'javascript'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/javascript/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/javascript/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/javascript/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_javascript() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-json")]
pub mod json {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_json() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_json() },
                "json",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'json'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/json/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_json() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-jsx")]
pub mod jsx {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_jsx() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_jsx() },
                "jsx",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'jsx'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/jsx/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/jsx/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/jsx/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_jsx() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-julia")]
pub mod julia {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_julia() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_julia() },
                "julia",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'julia'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/julia/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_julia() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-kotlin")]
pub mod kotlin {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_kotlin() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_kotlin() },
                "kotlin",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'kotlin'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/kotlin/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_kotlin() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-latex")]
pub mod latex {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_latex() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_latex() },
                "latex",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'latex'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/latex/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/latex/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_latex() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-llvm")]
pub mod llvm {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_llvm() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_llvm() },
                "llvm",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'llvm'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/llvm/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/llvm/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/llvm/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_llvm() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-lua")]
pub mod lua {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_lua() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_lua() },
                "lua",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'lua'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/lua/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/lua/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/lua/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_lua() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-make")]
pub mod make {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_make() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_make() },
                "make",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'make'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/make/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/make/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_make() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-matlab")]
pub mod matlab {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_matlab() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_matlab() },
                "matlab",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'matlab'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/matlab/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/matlab/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/matlab/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_matlab() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-meson")]
pub mod meson {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_meson() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_meson() },
                "meson",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'meson'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/meson/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_meson() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-nix")]
pub mod nix {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_nix() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_nix() },
                "nix",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'nix'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/nix/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/nix/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_nix() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-objc")]
pub mod objc {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_objc() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_objc() },
                "objc",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'objc'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/objc/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/objc/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/objc/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_objc() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-ocaml")]
pub mod ocaml {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_ocaml() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_ocaml() },
                "ocaml",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'ocaml'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/ocaml/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/ocaml/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_ocaml() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-ocaml-interface")]
pub mod ocaml_interface {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_ocaml_interface() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_ocaml_interface() },
                "ocaml_interface",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'ocaml_interface'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/ocaml_interface/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/ocaml_interface/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_ocaml_interface() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-openscad")]
pub mod openscad {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_openscad() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_openscad() },
                "openscad",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'openscad'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/openscad/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/openscad/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/openscad/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_openscad() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-pascal")]
pub mod pascal {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_pascal() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_pascal() },
                "pascal",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'pascal'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/pascal/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/pascal/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_pascal() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-php")]
pub mod php {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_php() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_php() },
                "php",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'php'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/php/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/php/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_php() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-plaintext")]
pub mod plaintext {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_plaintext() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_plaintext() },
                "plaintext",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'plaintext'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = "";
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_plaintext() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-proto")]
pub mod proto {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_proto() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_proto() },
                "proto",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'proto'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/proto/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_proto() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-python")]
pub mod python {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_python() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_python() },
                "python",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'python'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/python/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/python/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/python/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_python() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-r")]
pub mod r {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_r() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_r() },
                "r",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'r'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/r/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/r/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_r() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-racket")]
pub mod racket {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_racket() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_racket() },
                "racket",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'racket'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/racket/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/racket/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_racket() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-regex")]
pub mod regex {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_regex() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_regex() },
                "regex",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'regex'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/regex/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_regex() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-ruby")]
pub mod ruby {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_ruby() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_ruby() },
                "ruby",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'ruby'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/ruby/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/ruby/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/ruby/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_ruby() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-rust")]
pub mod rust {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_rust() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_rust() },
                "rust",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'rust'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/rust/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/rust/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/rust/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_rust() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-scala")]
pub mod scala {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_scala() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_scala() },
                "scala",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'scala'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/scala/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/scala/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = include_str!("../languages/scala/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_scala() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-scheme")]
pub mod scheme {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_scheme() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_scheme() },
                "scheme",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'scheme'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/scheme/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_scheme() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-scss")]
pub mod scss {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_scss() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_scss() },
                "scss",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'scss'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/scss/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/scss/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_scss() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-sql")]
pub mod sql {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_sql() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_sql() },
                "sql",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'sql'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/sql/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_sql() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-svelte")]
pub mod svelte {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_svelte() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_svelte() },
                "svelte",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'svelte'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/svelte/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/svelte/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_svelte() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-swift")]
pub mod swift {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_swift() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_swift() },
                "swift",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'swift'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/swift/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/swift/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_swift() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-toml")]
pub mod toml {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_toml() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_toml() },
                "toml",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'toml'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/toml/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/toml/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_toml() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-typescript")]
pub mod typescript {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_typescript() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_typescript() },
                "typescript",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect(
                "\"Failed to load highlight configuration for language 'typescript'\"",
            );
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/typescript/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!(
        "../languages/typescript/queries/locals.scm"
    );
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_typescript() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-tsx")]
pub mod tsx {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_tsx() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_tsx() },
                "tsx",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'tsx'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/tsx/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = include_str!("../languages/tsx/queries/locals.scm");
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_tsx() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-vim")]
pub mod vim {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_vim() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_vim() },
                "vim",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'vim'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/vim/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/vim/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_vim() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-wast")]
pub mod wast {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_wast() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_wast() },
                "wast",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'wast'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/wast/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_wast() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-wat")]
pub mod wat {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_wat() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_wat() },
                "wat",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'wat'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/wat/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_wat() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-x86asm")]
pub mod x86asm {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_x86asm() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_x86asm() },
                "x86asm",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'x86asm'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/x86asm/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_x86asm() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-wgsl")]
pub mod wgsl {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_wgsl() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_wgsl() },
                "wgsl",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'wgsl'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/wgsl/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = "";
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_wgsl() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-yaml")]
pub mod yaml {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_yaml() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_yaml() },
                "yaml",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'yaml'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/yaml/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/yaml/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_yaml() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
#[cfg(feature = "language-zig")]
pub mod zig {
    use std::sync::LazyLock;
    use tree_sitter::Language;
    use tree_sitter_highlight::HighlightConfiguration;
    use crate::constants::HIGHLIGHT_NAMES;
    extern "C" {
        pub fn tree_sitter_zig() -> Language;
    }
    pub static CONFIG: LazyLock<HighlightConfiguration> = LazyLock::new(|| {
        let mut config = HighlightConfiguration::new(
                unsafe { tree_sitter_zig() },
                "zig",
                HIGHLIGHT_QUERY,
                INJECTIONS_QUERY,
                LOCALS_QUERY,
            )
            .expect("\"Failed to load highlight configuration for language 'zig'\"");
        config.configure(HIGHLIGHT_NAMES);
        config
    });
    pub const HIGHLIGHT_QUERY: &str = include_str!(
        "../languages/zig/queries/highlights.scm"
    );
    pub const INJECTIONS_QUERY: &str = include_str!(
        "../languages/zig/queries/injections.scm"
    );
    pub const LOCALS_QUERY: &str = "";
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree_sitter_highlight::Highlighter;
        #[test]
        fn grammar_loading() {
            let mut parser = tree_sitter::Parser::new();
            parser
                .set_language(unsafe { &tree_sitter_zig() })
                .expect("Grammar should load successfully.");
        }
        #[test]
        fn config_loading() {
            let mut highlighter = Highlighter::new();
            let _events = highlighter
                .highlight(&CONFIG, b"", None, |_| None)
                .expect("Highlighter should generate events successfully.");
        }
    }
}
/// The set of all languages supported by Inkjet.
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Language {
    /// A language resolved at runtime using the provided function pointer.
    ///
    /// This allows languages not statically known to Inkjet to be used in formatting.
    ///
    /// # Examples
    /// ```rust
    /// # use inkjet::tree_sitter_highlight::HighlightConfiguration;
    /// # use inkjet::formatter;
    /// # use inkjet::Language;
    /// # use inkjet::Highlighter;
    /// fn rust_config() -> &'static HighlightConfiguration {
    ///     Language::Rust.config()
    /// }
    ///
    /// let code = r#"
    ///     fn main() {
    ///         println!("Hello, world!");
    ///     }
    /// "#;
    ///
    /// let mut highlighter = Highlighter::new();
    ///
    /// let _string = highlighter.highlight_to_string(
    ///     Language::Runtime(rust_config),
    ///     &formatter::Html,
    ///     code
    /// )
    /// .expect("Highlighting should not fail");
    /// ```
    Runtime(fn() -> &'static HighlightConfiguration),
    /// A plaintext "language." Highlighting with this is a no-op.
    #[cfg(feature = "language-plaintext")]
    Plaintext,
    #[cfg(feature = "language-ada")]
    Ada,
    #[cfg(feature = "language-asm")]
    Asm,
    #[cfg(feature = "language-awk")]
    Awk,
    #[cfg(feature = "language-bash")]
    Bash,
    #[cfg(feature = "language-bibtex")]
    Bibtex,
    #[cfg(feature = "language-bicep")]
    Bicep,
    #[cfg(feature = "language-blueprint")]
    Blueprint,
    #[cfg(feature = "language-c")]
    C,
    #[cfg(feature = "language-capnp")]
    Capnp,
    #[cfg(feature = "language-clojure")]
    Clojure,
    #[cfg(feature = "language-c-sharp")]
    CSharp,
    #[cfg(feature = "language-cpp")]
    Cpp,
    #[cfg(feature = "language-css")]
    Css,
    #[cfg(feature = "language-cue")]
    Cue,
    #[cfg(feature = "language-d")]
    D,
    #[cfg(feature = "language-dart")]
    Dart,
    #[cfg(feature = "language-diff")]
    Diff,
    #[cfg(feature = "language-dockerfile")]
    Dockerfile,
    #[cfg(feature = "language-eex")]
    Eex,
    #[cfg(feature = "language-elisp")]
    Elisp,
    #[cfg(feature = "language-elixir")]
    Elixir,
    #[cfg(feature = "language-elm")]
    Elm,
    #[cfg(feature = "language-erlang")]
    Erlang,
    #[cfg(feature = "language-forth")]
    Forth,
    #[cfg(feature = "language-fortran")]
    Fortran,
    #[cfg(feature = "language-fish")]
    Fish,
    #[cfg(feature = "language-gdscript")]
    Gdscript,
    #[cfg(feature = "language-gleam")]
    Gleam,
    #[cfg(feature = "language-glsl")]
    Glsl,
    #[cfg(feature = "language-go")]
    Go,
    #[cfg(feature = "language-haskell")]
    Haskell,
    #[cfg(feature = "language-hcl")]
    Hcl,
    #[cfg(feature = "language-heex")]
    Heex,
    #[cfg(feature = "language-html")]
    Html,
    #[cfg(feature = "language-ini")]
    Ini,
    #[cfg(feature = "language-java")]
    Java,
    #[cfg(feature = "language-javascript")]
    Javascript,
    #[cfg(feature = "language-json")]
    Json,
    #[cfg(feature = "language-jsx")]
    Jsx,
    #[cfg(feature = "language-julia")]
    Julia,
    #[cfg(feature = "language-kotlin")]
    Kotlin,
    #[cfg(feature = "language-latex")]
    Latex,
    #[cfg(feature = "language-llvm")]
    Llvm,
    #[cfg(feature = "language-lua")]
    Lua,
    #[cfg(feature = "language-make")]
    Make,
    #[cfg(feature = "language-matlab")]
    Matlab,
    #[cfg(feature = "language-meson")]
    Meson,
    #[cfg(feature = "language-nix")]
    Nix,
    #[cfg(feature = "language-objc")]
    ObjectiveC,
    #[cfg(feature = "language-ocaml")]
    Ocaml,
    #[cfg(feature = "language-ocaml-interface")]
    OcamlInterface,
    #[cfg(feature = "language-openscad")]
    OpenScad,
    #[cfg(feature = "language-pascal")]
    Pascal,
    #[cfg(feature = "language-php")]
    Php,
    #[cfg(feature = "language-proto")]
    ProtoBuf,
    #[cfg(feature = "language-python")]
    Python,
    #[cfg(feature = "language-r")]
    R,
    #[cfg(feature = "language-racket")]
    Racket,
    #[cfg(feature = "language-regex")]
    Regex,
    #[cfg(feature = "language-ruby")]
    Ruby,
    #[cfg(feature = "language-rust")]
    Rust,
    #[cfg(feature = "language-scala")]
    Scala,
    #[cfg(feature = "language-scheme")]
    Scheme,
    #[cfg(feature = "language-scss")]
    Scss,
    #[cfg(feature = "language-sql")]
    Sql,
    #[cfg(feature = "language-svelte")]
    Svelte,
    #[cfg(feature = "language-swift")]
    Swift,
    #[cfg(feature = "language-toml")]
    Toml,
    #[cfg(feature = "language-typescript")]
    Typescript,
    #[cfg(feature = "language-tsx")]
    Tsx,
    #[cfg(feature = "language-vim")]
    Vimscript,
    #[cfg(feature = "language-wast")]
    Wast,
    #[cfg(feature = "language-wat")]
    Wat,
    #[cfg(feature = "language-x86asm")]
    X86asm,
    #[cfg(feature = "language-wgsl")]
    Wgsl,
    #[cfg(feature = "language-yaml")]
    Yaml,
    #[cfg(feature = "language-zig")]
    Zig,
}
impl Language {
    /// Array containing all (statically known) language variants.
    pub const ALL_LANGS: &'static [Self] = &[
        #[cfg(feature = "language-ada")]
        Self::Ada,
        #[cfg(feature = "language-asm")]
        Self::Asm,
        #[cfg(feature = "language-awk")]
        Self::Awk,
        #[cfg(feature = "language-bash")]
        Self::Bash,
        #[cfg(feature = "language-bibtex")]
        Self::Bibtex,
        #[cfg(feature = "language-bicep")]
        Self::Bicep,
        #[cfg(feature = "language-blueprint")]
        Self::Blueprint,
        #[cfg(feature = "language-c")]
        Self::C,
        #[cfg(feature = "language-capnp")]
        Self::Capnp,
        #[cfg(feature = "language-clojure")]
        Self::Clojure,
        #[cfg(feature = "language-c-sharp")]
        Self::CSharp,
        #[cfg(feature = "language-cpp")]
        Self::Cpp,
        #[cfg(feature = "language-css")]
        Self::Css,
        #[cfg(feature = "language-cue")]
        Self::Cue,
        #[cfg(feature = "language-d")]
        Self::D,
        #[cfg(feature = "language-dart")]
        Self::Dart,
        #[cfg(feature = "language-diff")]
        Self::Diff,
        #[cfg(feature = "language-dockerfile")]
        Self::Dockerfile,
        #[cfg(feature = "language-eex")]
        Self::Eex,
        #[cfg(feature = "language-elisp")]
        Self::Elisp,
        #[cfg(feature = "language-elixir")]
        Self::Elixir,
        #[cfg(feature = "language-elm")]
        Self::Elm,
        #[cfg(feature = "language-erlang")]
        Self::Erlang,
        #[cfg(feature = "language-forth")]
        Self::Forth,
        #[cfg(feature = "language-fortran")]
        Self::Fortran,
        #[cfg(feature = "language-fish")]
        Self::Fish,
        #[cfg(feature = "language-gdscript")]
        Self::Gdscript,
        #[cfg(feature = "language-gleam")]
        Self::Gleam,
        #[cfg(feature = "language-glsl")]
        Self::Glsl,
        #[cfg(feature = "language-go")]
        Self::Go,
        #[cfg(feature = "language-haskell")]
        Self::Haskell,
        #[cfg(feature = "language-hcl")]
        Self::Hcl,
        #[cfg(feature = "language-heex")]
        Self::Heex,
        #[cfg(feature = "language-html")]
        Self::Html,
        #[cfg(feature = "language-ini")]
        Self::Ini,
        #[cfg(feature = "language-java")]
        Self::Java,
        #[cfg(feature = "language-javascript")]
        Self::Javascript,
        #[cfg(feature = "language-json")]
        Self::Json,
        #[cfg(feature = "language-jsx")]
        Self::Jsx,
        #[cfg(feature = "language-julia")]
        Self::Julia,
        #[cfg(feature = "language-kotlin")]
        Self::Kotlin,
        #[cfg(feature = "language-latex")]
        Self::Latex,
        #[cfg(feature = "language-llvm")]
        Self::Llvm,
        #[cfg(feature = "language-lua")]
        Self::Lua,
        #[cfg(feature = "language-make")]
        Self::Make,
        #[cfg(feature = "language-matlab")]
        Self::Matlab,
        #[cfg(feature = "language-meson")]
        Self::Meson,
        #[cfg(feature = "language-nix")]
        Self::Nix,
        #[cfg(feature = "language-objc")]
        Self::ObjectiveC,
        #[cfg(feature = "language-ocaml")]
        Self::Ocaml,
        #[cfg(feature = "language-ocaml-interface")]
        Self::OcamlInterface,
        #[cfg(feature = "language-openscad")]
        Self::OpenScad,
        #[cfg(feature = "language-pascal")]
        Self::Pascal,
        #[cfg(feature = "language-php")]
        Self::Php,
        #[cfg(feature = "language-plaintext")]
        Self::Plaintext,
        #[cfg(feature = "language-proto")]
        Self::ProtoBuf,
        #[cfg(feature = "language-python")]
        Self::Python,
        #[cfg(feature = "language-r")]
        Self::R,
        #[cfg(feature = "language-racket")]
        Self::Racket,
        #[cfg(feature = "language-regex")]
        Self::Regex,
        #[cfg(feature = "language-ruby")]
        Self::Ruby,
        #[cfg(feature = "language-rust")]
        Self::Rust,
        #[cfg(feature = "language-scala")]
        Self::Scala,
        #[cfg(feature = "language-scheme")]
        Self::Scheme,
        #[cfg(feature = "language-scss")]
        Self::Scss,
        #[cfg(feature = "language-sql")]
        Self::Sql,
        #[cfg(feature = "language-svelte")]
        Self::Svelte,
        #[cfg(feature = "language-swift")]
        Self::Swift,
        #[cfg(feature = "language-toml")]
        Self::Toml,
        #[cfg(feature = "language-typescript")]
        Self::Typescript,
        #[cfg(feature = "language-tsx")]
        Self::Tsx,
        #[cfg(feature = "language-vim")]
        Self::Vimscript,
        #[cfg(feature = "language-wast")]
        Self::Wast,
        #[cfg(feature = "language-wat")]
        Self::Wat,
        #[cfg(feature = "language-x86asm")]
        Self::X86asm,
        #[cfg(feature = "language-wgsl")]
        Self::Wgsl,
        #[cfg(feature = "language-yaml")]
        Self::Yaml,
        #[cfg(feature = "language-zig")]
        Self::Zig,
    ];
    /// Attempts to convert a string token (such as `rust` or `rs`) into the corresponding language.
    ///
    /// Returns [`None`] if the language was not found.
    ///
    /// The tokens for each language are sourced from its `name` and `aliases` keys in
    /// `build/languages.toml`.
    ///
    /// # Example
    /// ```rust
    /// # use inkjet::Language;
    /// assert_eq!(
    ///     Language::from_token("rs").unwrap(),
    ///     Language::Rust
    /// );
    /// ```
    pub fn from_token(token: impl AsRef<str>) -> Option<Self> {
        match token.as_ref() {
            #[cfg(feature = "language-ada")]
            "ada" => Some(Self::Ada),
            #[cfg(feature = "language-asm")]
            "asm" => Some(Self::Asm),
            #[cfg(feature = "language-asm")]
            "assembly" => Some(Self::Asm),
            #[cfg(feature = "language-asm")]
            "assembler" => Some(Self::Asm),
            #[cfg(feature = "language-awk")]
            "awk" => Some(Self::Awk),
            #[cfg(feature = "language-bash")]
            "bash" => Some(Self::Bash),
            #[cfg(feature = "language-bash")]
            "sh" => Some(Self::Bash),
            #[cfg(feature = "language-bash")]
            "shell" => Some(Self::Bash),
            #[cfg(feature = "language-bibtex")]
            "bibtex" => Some(Self::Bibtex),
            #[cfg(feature = "language-bibtex")]
            "bib" => Some(Self::Bibtex),
            #[cfg(feature = "language-bicep")]
            "bicep" => Some(Self::Bicep),
            #[cfg(feature = "language-blueprint")]
            "blueprint" => Some(Self::Blueprint),
            #[cfg(feature = "language-blueprint")]
            "blp" => Some(Self::Blueprint),
            #[cfg(feature = "language-c")]
            "c" => Some(Self::C),
            #[cfg(feature = "language-c")]
            "h" => Some(Self::C),
            #[cfg(feature = "language-capnp")]
            "capnp" => Some(Self::Capnp),
            #[cfg(feature = "language-clojure")]
            "clojure" => Some(Self::Clojure),
            #[cfg(feature = "language-clojure")]
            "clj" => Some(Self::Clojure),
            #[cfg(feature = "language-clojure")]
            "cljc" => Some(Self::Clojure),
            #[cfg(feature = "language-c-sharp")]
            "c_sharp" => Some(Self::CSharp),
            #[cfg(feature = "language-c-sharp")]
            "c#" => Some(Self::CSharp),
            #[cfg(feature = "language-c-sharp")]
            "csharp" => Some(Self::CSharp),
            #[cfg(feature = "language-c-sharp")]
            "cs" => Some(Self::CSharp),
            #[cfg(feature = "language-cpp")]
            "cpp" => Some(Self::Cpp),
            #[cfg(feature = "language-cpp")]
            "c++" => Some(Self::Cpp),
            #[cfg(feature = "language-cpp")]
            "hpp" => Some(Self::Cpp),
            #[cfg(feature = "language-cpp")]
            "h++" => Some(Self::Cpp),
            #[cfg(feature = "language-cpp")]
            "cc" => Some(Self::Cpp),
            #[cfg(feature = "language-cpp")]
            "hh" => Some(Self::Cpp),
            #[cfg(feature = "language-css")]
            "css" => Some(Self::Css),
            #[cfg(feature = "language-cue")]
            "cue" => Some(Self::Cue),
            #[cfg(feature = "language-d")]
            "d" => Some(Self::D),
            #[cfg(feature = "language-d")]
            "dlang" => Some(Self::D),
            #[cfg(feature = "language-dart")]
            "dart" => Some(Self::Dart),
            #[cfg(feature = "language-diff")]
            "diff" => Some(Self::Diff),
            #[cfg(feature = "language-dockerfile")]
            "dockerfile" => Some(Self::Dockerfile),
            #[cfg(feature = "language-dockerfile")]
            "docker" => Some(Self::Dockerfile),
            #[cfg(feature = "language-eex")]
            "eex" => Some(Self::Eex),
            #[cfg(feature = "language-elisp")]
            "elisp" => Some(Self::Elisp),
            #[cfg(feature = "language-elisp")]
            "el" => Some(Self::Elisp),
            #[cfg(feature = "language-elisp")]
            "emacs-lisp" => Some(Self::Elisp),
            #[cfg(feature = "language-elixir")]
            "elixir" => Some(Self::Elixir),
            #[cfg(feature = "language-elixir")]
            "ex" => Some(Self::Elixir),
            #[cfg(feature = "language-elixir")]
            "exs" => Some(Self::Elixir),
            #[cfg(feature = "language-elixir")]
            "leex" => Some(Self::Elixir),
            #[cfg(feature = "language-elm")]
            "elm" => Some(Self::Elm),
            #[cfg(feature = "language-erlang")]
            "erlang" => Some(Self::Erlang),
            #[cfg(feature = "language-erlang")]
            "erl" => Some(Self::Erlang),
            #[cfg(feature = "language-erlang")]
            "hrl" => Some(Self::Erlang),
            #[cfg(feature = "language-erlang")]
            "es" => Some(Self::Erlang),
            #[cfg(feature = "language-erlang")]
            "escript" => Some(Self::Erlang),
            #[cfg(feature = "language-forth")]
            "forth" => Some(Self::Forth),
            #[cfg(feature = "language-forth")]
            "fth" => Some(Self::Forth),
            #[cfg(feature = "language-fortran")]
            "fortran" => Some(Self::Fortran),
            #[cfg(feature = "language-fortran")]
            "for" => Some(Self::Fortran),
            #[cfg(feature = "language-fish")]
            "fish" => Some(Self::Fish),
            #[cfg(feature = "language-gdscript")]
            "gdscript" => Some(Self::Gdscript),
            #[cfg(feature = "language-gdscript")]
            "gd" => Some(Self::Gdscript),
            #[cfg(feature = "language-gleam")]
            "gleam" => Some(Self::Gleam),
            #[cfg(feature = "language-glsl")]
            "glsl" => Some(Self::Glsl),
            #[cfg(feature = "language-go")]
            "go" => Some(Self::Go),
            #[cfg(feature = "language-go")]
            "golang" => Some(Self::Go),
            #[cfg(feature = "language-haskell")]
            "haskell" => Some(Self::Haskell),
            #[cfg(feature = "language-haskell")]
            "hs" => Some(Self::Haskell),
            #[cfg(feature = "language-hcl")]
            "hcl" => Some(Self::Hcl),
            #[cfg(feature = "language-hcl")]
            "terraform" => Some(Self::Hcl),
            #[cfg(feature = "language-heex")]
            "heex" => Some(Self::Heex),
            #[cfg(feature = "language-html")]
            "html" => Some(Self::Html),
            #[cfg(feature = "language-html")]
            "htm" => Some(Self::Html),
            #[cfg(feature = "language-ini")]
            "ini" => Some(Self::Ini),
            #[cfg(feature = "language-java")]
            "java" => Some(Self::Java),
            #[cfg(feature = "language-javascript")]
            "javascript" => Some(Self::Javascript),
            #[cfg(feature = "language-javascript")]
            "js" => Some(Self::Javascript),
            #[cfg(feature = "language-json")]
            "json" => Some(Self::Json),
            #[cfg(feature = "language-jsx")]
            "jsx" => Some(Self::Jsx),
            #[cfg(feature = "language-julia")]
            "julia" => Some(Self::Julia),
            #[cfg(feature = "language-julia")]
            "jl" => Some(Self::Julia),
            #[cfg(feature = "language-kotlin")]
            "kotlin" => Some(Self::Kotlin),
            #[cfg(feature = "language-kotlin")]
            "kt" => Some(Self::Kotlin),
            #[cfg(feature = "language-kotlin")]
            "kts" => Some(Self::Kotlin),
            #[cfg(feature = "language-latex")]
            "latex" => Some(Self::Latex),
            #[cfg(feature = "language-latex")]
            "tex" => Some(Self::Latex),
            #[cfg(feature = "language-llvm")]
            "llvm" => Some(Self::Llvm),
            #[cfg(feature = "language-lua")]
            "lua" => Some(Self::Lua),
            #[cfg(feature = "language-make")]
            "make" => Some(Self::Make),
            #[cfg(feature = "language-make")]
            "mk" => Some(Self::Make),
            #[cfg(feature = "language-make")]
            "makefile" => Some(Self::Make),
            #[cfg(feature = "language-matlab")]
            "matlab" => Some(Self::Matlab),
            #[cfg(feature = "language-matlab")]
            "m" => Some(Self::Matlab),
            #[cfg(feature = "language-meson")]
            "meson" => Some(Self::Meson),
            #[cfg(feature = "language-nix")]
            "nix" => Some(Self::Nix),
            #[cfg(feature = "language-objc")]
            "objc" => Some(Self::ObjectiveC),
            #[cfg(feature = "language-objc")]
            "objective_c" => Some(Self::ObjectiveC),
            #[cfg(feature = "language-ocaml")]
            "ocaml" => Some(Self::Ocaml),
            #[cfg(feature = "language-ocaml")]
            "ml" => Some(Self::Ocaml),
            #[cfg(feature = "language-ocaml-interface")]
            "ocaml_interface" => Some(Self::OcamlInterface),
            #[cfg(feature = "language-ocaml-interface")]
            "mli" => Some(Self::OcamlInterface),
            #[cfg(feature = "language-openscad")]
            "openscad" => Some(Self::OpenScad),
            #[cfg(feature = "language-openscad")]
            "scad" => Some(Self::OpenScad),
            #[cfg(feature = "language-pascal")]
            "pascal" => Some(Self::Pascal),
            #[cfg(feature = "language-php")]
            "php" => Some(Self::Php),
            #[cfg(feature = "language-plaintext")]
            "plaintext" => Some(Self::Plaintext),
            #[cfg(feature = "language-plaintext")]
            "none" => Some(Self::Plaintext),
            #[cfg(feature = "language-plaintext")]
            "nolang" => Some(Self::Plaintext),
            #[cfg(feature = "language-proto")]
            "proto" => Some(Self::ProtoBuf),
            #[cfg(feature = "language-proto")]
            "protobuf" => Some(Self::ProtoBuf),
            #[cfg(feature = "language-python")]
            "python" => Some(Self::Python),
            #[cfg(feature = "language-python")]
            "py" => Some(Self::Python),
            #[cfg(feature = "language-r")]
            "r" => Some(Self::R),
            #[cfg(feature = "language-racket")]
            "racket" => Some(Self::Racket),
            #[cfg(feature = "language-racket")]
            "rkt" => Some(Self::Racket),
            #[cfg(feature = "language-regex")]
            "regex" => Some(Self::Regex),
            #[cfg(feature = "language-ruby")]
            "ruby" => Some(Self::Ruby),
            #[cfg(feature = "language-ruby")]
            "rb" => Some(Self::Ruby),
            #[cfg(feature = "language-rust")]
            "rust" => Some(Self::Rust),
            #[cfg(feature = "language-rust")]
            "rs" => Some(Self::Rust),
            #[cfg(feature = "language-scala")]
            "scala" => Some(Self::Scala),
            #[cfg(feature = "language-scheme")]
            "scheme" => Some(Self::Scheme),
            #[cfg(feature = "language-scheme")]
            "scm" => Some(Self::Scheme),
            #[cfg(feature = "language-scheme")]
            "ss" => Some(Self::Scheme),
            #[cfg(feature = "language-scss")]
            "scss" => Some(Self::Scss),
            #[cfg(feature = "language-sql")]
            "sql" => Some(Self::Sql),
            #[cfg(feature = "language-svelte")]
            "svelte" => Some(Self::Svelte),
            #[cfg(feature = "language-swift")]
            "swift" => Some(Self::Swift),
            #[cfg(feature = "language-toml")]
            "toml" => Some(Self::Toml),
            #[cfg(feature = "language-typescript")]
            "typescript" => Some(Self::Typescript),
            #[cfg(feature = "language-typescript")]
            "ts" => Some(Self::Typescript),
            #[cfg(feature = "language-tsx")]
            "tsx" => Some(Self::Tsx),
            #[cfg(feature = "language-vim")]
            "vim" => Some(Self::Vimscript),
            #[cfg(feature = "language-vim")]
            "vimscript" => Some(Self::Vimscript),
            #[cfg(feature = "language-wast")]
            "wast" => Some(Self::Wast),
            #[cfg(feature = "language-wat")]
            "wat" => Some(Self::Wat),
            #[cfg(feature = "language-wat")]
            "wasm" => Some(Self::Wat),
            #[cfg(feature = "language-x86asm")]
            "x86asm" => Some(Self::X86asm),
            #[cfg(feature = "language-x86asm")]
            "x86" => Some(Self::X86asm),
            #[cfg(feature = "language-wgsl")]
            "wgsl" => Some(Self::Wgsl),
            #[cfg(feature = "language-yaml")]
            "yaml" => Some(Self::Yaml),
            #[cfg(feature = "language-zig")]
            "zig" => Some(Self::Zig),
            _ => None,
        }
    }
    /// Get the underlying [`HighlightConfiguration`] for a language.
    pub fn config(&self) -> &'static HighlightConfiguration {
        match *self {
            #[cfg(feature = "language-ada")]
            Self::Ada => &ada::CONFIG,
            #[cfg(feature = "language-asm")]
            Self::Asm => &asm::CONFIG,
            #[cfg(feature = "language-awk")]
            Self::Awk => &awk::CONFIG,
            #[cfg(feature = "language-bash")]
            Self::Bash => &bash::CONFIG,
            #[cfg(feature = "language-bibtex")]
            Self::Bibtex => &bibtex::CONFIG,
            #[cfg(feature = "language-bicep")]
            Self::Bicep => &bicep::CONFIG,
            #[cfg(feature = "language-blueprint")]
            Self::Blueprint => &blueprint::CONFIG,
            #[cfg(feature = "language-c")]
            Self::C => &c::CONFIG,
            #[cfg(feature = "language-capnp")]
            Self::Capnp => &capnp::CONFIG,
            #[cfg(feature = "language-clojure")]
            Self::Clojure => &clojure::CONFIG,
            #[cfg(feature = "language-c-sharp")]
            Self::CSharp => &c_sharp::CONFIG,
            #[cfg(feature = "language-cpp")]
            Self::Cpp => &cpp::CONFIG,
            #[cfg(feature = "language-css")]
            Self::Css => &css::CONFIG,
            #[cfg(feature = "language-cue")]
            Self::Cue => &cue::CONFIG,
            #[cfg(feature = "language-d")]
            Self::D => &d::CONFIG,
            #[cfg(feature = "language-dart")]
            Self::Dart => &dart::CONFIG,
            #[cfg(feature = "language-diff")]
            Self::Diff => &diff::CONFIG,
            #[cfg(feature = "language-dockerfile")]
            Self::Dockerfile => &dockerfile::CONFIG,
            #[cfg(feature = "language-eex")]
            Self::Eex => &eex::CONFIG,
            #[cfg(feature = "language-elisp")]
            Self::Elisp => &elisp::CONFIG,
            #[cfg(feature = "language-elixir")]
            Self::Elixir => &elixir::CONFIG,
            #[cfg(feature = "language-elm")]
            Self::Elm => &elm::CONFIG,
            #[cfg(feature = "language-erlang")]
            Self::Erlang => &erlang::CONFIG,
            #[cfg(feature = "language-forth")]
            Self::Forth => &forth::CONFIG,
            #[cfg(feature = "language-fortran")]
            Self::Fortran => &fortran::CONFIG,
            #[cfg(feature = "language-fish")]
            Self::Fish => &fish::CONFIG,
            #[cfg(feature = "language-gdscript")]
            Self::Gdscript => &gdscript::CONFIG,
            #[cfg(feature = "language-gleam")]
            Self::Gleam => &gleam::CONFIG,
            #[cfg(feature = "language-glsl")]
            Self::Glsl => &glsl::CONFIG,
            #[cfg(feature = "language-go")]
            Self::Go => &go::CONFIG,
            #[cfg(feature = "language-haskell")]
            Self::Haskell => &haskell::CONFIG,
            #[cfg(feature = "language-hcl")]
            Self::Hcl => &hcl::CONFIG,
            #[cfg(feature = "language-heex")]
            Self::Heex => &heex::CONFIG,
            #[cfg(feature = "language-html")]
            Self::Html => &html::CONFIG,
            #[cfg(feature = "language-ini")]
            Self::Ini => &ini::CONFIG,
            #[cfg(feature = "language-java")]
            Self::Java => &java::CONFIG,
            #[cfg(feature = "language-javascript")]
            Self::Javascript => &javascript::CONFIG,
            #[cfg(feature = "language-json")]
            Self::Json => &json::CONFIG,
            #[cfg(feature = "language-jsx")]
            Self::Jsx => &jsx::CONFIG,
            #[cfg(feature = "language-julia")]
            Self::Julia => &julia::CONFIG,
            #[cfg(feature = "language-kotlin")]
            Self::Kotlin => &kotlin::CONFIG,
            #[cfg(feature = "language-latex")]
            Self::Latex => &latex::CONFIG,
            #[cfg(feature = "language-llvm")]
            Self::Llvm => &llvm::CONFIG,
            #[cfg(feature = "language-lua")]
            Self::Lua => &lua::CONFIG,
            #[cfg(feature = "language-make")]
            Self::Make => &make::CONFIG,
            #[cfg(feature = "language-matlab")]
            Self::Matlab => &matlab::CONFIG,
            #[cfg(feature = "language-meson")]
            Self::Meson => &meson::CONFIG,
            #[cfg(feature = "language-nix")]
            Self::Nix => &nix::CONFIG,
            #[cfg(feature = "language-objc")]
            Self::ObjectiveC => &objc::CONFIG,
            #[cfg(feature = "language-ocaml")]
            Self::Ocaml => &ocaml::CONFIG,
            #[cfg(feature = "language-ocaml-interface")]
            Self::OcamlInterface => &ocaml_interface::CONFIG,
            #[cfg(feature = "language-openscad")]
            Self::OpenScad => &openscad::CONFIG,
            #[cfg(feature = "language-pascal")]
            Self::Pascal => &pascal::CONFIG,
            #[cfg(feature = "language-php")]
            Self::Php => &php::CONFIG,
            #[cfg(feature = "language-plaintext")]
            Self::Plaintext => &plaintext::CONFIG,
            #[cfg(feature = "language-proto")]
            Self::ProtoBuf => &proto::CONFIG,
            #[cfg(feature = "language-python")]
            Self::Python => &python::CONFIG,
            #[cfg(feature = "language-r")]
            Self::R => &r::CONFIG,
            #[cfg(feature = "language-racket")]
            Self::Racket => &racket::CONFIG,
            #[cfg(feature = "language-regex")]
            Self::Regex => &regex::CONFIG,
            #[cfg(feature = "language-ruby")]
            Self::Ruby => &ruby::CONFIG,
            #[cfg(feature = "language-rust")]
            Self::Rust => &rust::CONFIG,
            #[cfg(feature = "language-scala")]
            Self::Scala => &scala::CONFIG,
            #[cfg(feature = "language-scheme")]
            Self::Scheme => &scheme::CONFIG,
            #[cfg(feature = "language-scss")]
            Self::Scss => &scss::CONFIG,
            #[cfg(feature = "language-sql")]
            Self::Sql => &sql::CONFIG,
            #[cfg(feature = "language-svelte")]
            Self::Svelte => &svelte::CONFIG,
            #[cfg(feature = "language-swift")]
            Self::Swift => &swift::CONFIG,
            #[cfg(feature = "language-toml")]
            Self::Toml => &toml::CONFIG,
            #[cfg(feature = "language-typescript")]
            Self::Typescript => &typescript::CONFIG,
            #[cfg(feature = "language-tsx")]
            Self::Tsx => &tsx::CONFIG,
            #[cfg(feature = "language-vim")]
            Self::Vimscript => &vim::CONFIG,
            #[cfg(feature = "language-wast")]
            Self::Wast => &wast::CONFIG,
            #[cfg(feature = "language-wat")]
            Self::Wat => &wat::CONFIG,
            #[cfg(feature = "language-x86asm")]
            Self::X86asm => &x86asm::CONFIG,
            #[cfg(feature = "language-wgsl")]
            Self::Wgsl => &wgsl::CONFIG,
            #[cfg(feature = "language-yaml")]
            Self::Yaml => &yaml::CONFIG,
            #[cfg(feature = "language-zig")]
            Self::Zig => &zig::CONFIG,
            Self::Runtime(ptr) => ptr(),
        }
    }
}
