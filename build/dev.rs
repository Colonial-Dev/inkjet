use std::fs::{self, File};
use std::io::Write;
use std::process::Command;

use anyhow::Result;
use fs_extra::dir::{self, CopyOptions};

use crate::codegen;
use crate::Language;

pub fn check(languages: &[Language]) -> Result<()> {
    if std::env::var("INKJET_REDOWNLOAD_LANGS").is_ok() {
        download_langs(languages)?;
    }

    if std::env::var("INKJET_REBUILD_LANGS_MODULE").is_ok() {
        generate_langs_module(languages)?;
    }

    if std::env::var("INKJET_REBUILD_FEATURES").is_ok() {
        generate_features_list(languages)?;
    }

    Ok(())
} 

pub fn download_langs(languages: &[Language]) -> Result<()> {
    fs::remove_dir_all("languages")?;
    fs::create_dir_all("languages/temp/helix_queries")?;

    Command::new("git")
        .arg("clone")
        .arg("https://github.com/helix-editor/helix")
        .arg("languages/temp/helix_all")
        .spawn()?
        .wait()?;

    dir::copy(
        "languages/temp/helix_all/runtime/queries/",
        "languages/temp/helix_queries",
        &CopyOptions::new().content_only(true)
    )?;

    let downloads: Vec<_> = languages
        .iter()
        .map(Language::download)
        .map(Result::unwrap)
        .zip(languages)
        .collect();

    for (mut child, lang) in downloads {
        child.wait()?;

        println!("Finished downloading {}.", lang.name);

        if lang.hash.is_some() && lang.command.is_none() {
            let hash = lang.hash.as_ref().unwrap();
            let repo_dir = format!("languages/temp/{}", lang.name);

            Command::new("git")
                .current_dir(repo_dir)
                .args(["reset", "--hard", hash])
                .spawn()?
                .wait()?;
        }

        fs::create_dir_all(format!("languages/{}/queries", lang.name))?;

        dir::copy(
            format!("languages/temp/{}/src", lang.name),
            format!("languages/{}", lang.name),
            &CopyOptions::new(),
        )?;

        let query_path = match &lang.helix_path {
            Some(path) => format!("languages/temp/helix_queries/{path}"),
            None => format!("languages/temp/helix_queries/{}", lang.name)
        };

        let query_path = match lang.helix_override {
            false => query_path,
            true => format!("languages/temp/{}/queries", lang.name)
        };

        dir::copy(
            query_path,
            format!("languages/{}/queries", lang.name),
            &CopyOptions::new().content_only(true),
        )?;

        // Remove unneeded queries and JSON data.
        // We discard the error because these files might not be there.
        let _ = fs::remove_file(format!("languages/{}/queries/textobjects.scm", lang.name));
        let _ = fs::remove_file(format!("languages/{}/queries/indents.scm", lang.name));
        let _ = fs::remove_file(format!("languages/{}/queries/folds.scm", lang.name));
        let _ = fs::remove_file(format!("languages/{}/src/grammar.json", lang.name));
        let _ = fs::remove_file(format!("languages/{}/src/node-types.json", lang.name));

        println!("Finished extracting {}.", lang.name);
    }

    fs::remove_dir_all("languages/temp")?;

    Ok(())
}

pub fn generate_langs_module(languages: &[Language]) -> Result<()> {
    let module_start = quote::quote! {
        //! This module is automatically generated by Inkjet.
        #![allow(dead_code)]
        #![allow(clippy::items_after_test_module)]

        use tree_sitter_highlight::HighlightConfiguration;
    };

    let modules = languages
        .iter()
        .map(codegen::language_module_def);

    let language_enum_def = codegen::languages_enum_def(languages);
    let language_impl_def = codegen::languages_impl_def(languages);

    let combined = quote::quote!{
        #module_start
        #(#modules)*
        #language_enum_def
        #language_impl_def
    };

    let combined = format!("{combined}");
    let combined = syn::parse_file(&combined).unwrap();
    let combined = prettyplease::unparse(&combined);

    let mut file = File::create("src/languages.rs")?;

    write!(&mut file, "{}", combined)?;

    Ok(())
}

pub fn generate_features_list(languages: &[Language]) -> Result<()> {
    let mut all_languages_buffer = String::new();
    let mut features_buffer = String::new();

    for lang in languages {
        all_languages_buffer += &format!("\"language-{}\",\n", lang.name.replace('_', "-"));
        features_buffer += &format!("language-{} = []\n", lang.name.replace('_', "-"));
    }

    let mut file = fs::File::create("features")?;

    write!(
        file,
        "
            all_languages = [
                {all_languages_buffer}
            ]

            {features_buffer}
        "
    )?;

    Ok(())
}